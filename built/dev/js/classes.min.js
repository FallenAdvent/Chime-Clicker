var Achievement = function() {
  this.Init();
};

Achievement.prototype.Init = function() {
};

Achievement.Create = function(game) {
};

var Item = function(game, cost, level, defenseStat, movespeedStat, damageStat, attackrateStat, income) {
  this.Init(game, cost, level, defenseStat, movespeedStat, damageStat, attackrateStat, income);
};

Item.prototype.Init = function(game, cost, level, defenseStat, movespeedStat, damageStat, attackrateStat, income) {
  this.game = game;
  this.cost = cost;
  this.level = level;
  this.startCost = cost;
  this.defenseStat = defenseStat;
  this.movespeedStat = movespeedStat;
  this.damageStat = damageStat;
  this.attackrateStat = attackrateStat;
  this.income = income;

  this.unlock = function(game) {
    return game.level >= this.level;
  };

  this.status = LOCKED;
  this.count = 0;

  this.upgrades = [];
  this.upgradesAvailable = [];

  this.cost10 = this.calculatePurchaseCost(10);
  this.cost100 = this.calculatePurchaseCost(100);
  this.cost1000 = this.calculatePurchaseCost(1000);
};

Item.prototype.calculateTotalCost  = function(n) {
  return this.startCost * SCALE_ITEM_COST * ((Math.pow(n, 3) - n) / 6) + n * this.startCost;
};

Item.prototype.calculatePurchaseCost  = function(n) {
  return this.calculateTotalCost(n + this.count) - this.calculateTotalCost(this.count);
};

Item.convertUpgradeToIndex = function(upgrades) {
  var result = [];
  var len = upgrades.length;
  var i = 0;
  while (i < len) {
    result.push(upgradeToIndex(upgrades[i]));
    i++;
  }
  return result;
};

Item.convertIndexToUpgrade = function(indices) {
  var result = [];
  var len = indices.length;
  var i = 0;
  while (i < len) {
    result.push(indexToUpgrade(indices[i]));
    i++;
  }
  return result;
};

Item.Create = function(game) {
  var items = {};

  items[RELIC_SHIELD] = new Item(game, 250, 1,      2, 0, 0, 0, 1);
  items[ANCIENT_COIN] = new Item(game, 250, 1,      0, 0, 0, 0, 5);
  items[SPELLTHIEFS_EDGE] = new Item(game, 250, 1,  0, 0, 10, 0, 3);
  items[BOOTS_OF_SPEED] = new Item(game, 750, 2,    0, 1, 0, 0, 0);
  items[RUBY_CRYSTAL] = new Item(game, 750, 2,      10, 0, 0, 0, 0);
  items[AMPLIFYING_TOME] = new Item(game, 3000, 3,  0, 0, 50, 0, 0);
  items[DAGGER] = new Item(game, 3000, 3,           0, 0, 0, 1, 0);

  return items;
};

var Mastery = function() {
  this.Init();
};

Mastery.prototype.Init = function() {
};

Mastery.Create = function(game) {
};

var Monster = function(game, level, health, experience, gold, type) {
  this.Init(game, level, health, experience, gold, type);
};

Monster.prototype.Init = function(game, level, health, experience, gold, type) {
  this.game = game;
  this.level = level;
  this.maxHealth = health;
  this.currentHealth = health;
  this.experience = experience;
  this.gold = gold;
  this.type = type;

  this.startHealth = health;
  this.startExperience = experience;
  this.startGold = gold;

  this.count = 0;
  this.status = LOCKED;
};

Monster.Create = function(game) {
  var monsters = {};
  var monster;
  var baseHealth;
  var scaleHealth;
  var totalHealth;
  var scaleExp;
  var scaleReward;
  var type;
  var i;
  var len = MONSTERS.length;
  for (i = 0; i < len; i++) {
    monster = MONSTERS[i];
    baseHealth = MONSTER_HEALTH + 12 * Math.pow(i, 2) + 25 * i;
    scaleHealth = Math.pow(game.scaleMonsterLevelHealth, i);
    totalHealth = Math.floor(baseHealth * scaleHealth);
    scaleExp = Math.pow(SCALE_MONSTER_LEVEL_REWARD, i);
    scaleReward = Math.pow(SCALE_MONSTER_LEVEL_REWARD, i);
    if (i == len - 1) {
      var health = totalHealth * 15;
      var healthPower = Math.floor(getBaseLog(10, health));
      var newHealth = Math.pow(10, healthPower) * (1.11111).toFixed(2 + healthPower % 3);
      newHealth = Math.ceil(health / newHealth) * newHealth;

      totalHealth =  newHealth;
      scaleExp = 999990000000000000 / MONSTER_EXPERIENCE;
      scaleReward = 999990000000000 / MONSTER_REWARD;
    }

    type = game.isMonsterChampion(monster) ? MONSTER_CHAMPION : MONSTER_JUNGLE;
    monsters[monster] = new Monster(game, i + 1, totalHealth,
                                                 MONSTER_EXPERIENCE * scaleExp + 10 * (i + 1),
                                                 MONSTER_REWARD * scaleReward + 10 * (i + 1),
                                                 type);
  }
  return monsters;
};

var Rune = function (game, type, name, tier, difficulty, apply, tooltip) {
  this.Init(game, type, name, tier, difficulty, apply, tooltip);
};
Rune.prototype.Init = function (game, type, name, tier, difficulty, apply, tooltip) {
  this.game = game;
  this.type = type;
  this.name = name;
  this.tier = tier;
  this.difficulty = difficulty;
  this.apply = apply;
  this.tooltip = tooltip;
  this.fullName = type.capitalize() + ' of ' + name;
  this.cost = RUNE_PRICES[difficulty] * Math.pow(10, tier - 1) * (type == QUINT ? 4 : 1);
  this.status = LOCKED;
  this.purchased = 0;
  this.count = 0;
  this.active = 0;
  this.image = Rune.GetImageName(this);
  this.unlock = function (game) {
    return DIFFICULTIES.indexOf(game.difficulty) >= DIFFICULTIES.indexOf(this.difficulty);
  };
};
Rune.prototype.getLockedText = function () {
  return 'Unlock by completing <b>' + this.difficulty.capitalize() + '</b>';
};
Rune.prototype.getPurchasedPercent = function () {
  if (!this.purchased)
    return 0;
  return 100 * this.purchased / (this.type == QUINT ? 3 : 9);
};
Rune.prototype.getActivePercent = function () {
  if (!this.purchased)
    return 0;
  return 100 * this.count / this.purchased;
};
Rune.GetImageName = function (rune) {
  var s = '';
  if (rune.type == MARK) {
    s += 'r_';
    if (rune.difficulty == 'medium')
      s += '1_';
    else if (rune.difficulty == 'hard')
      s += '2_';
    else if (rune.difficulty == 'marathon')
      s += '4_';
  } else if (rune.type == SEAL) {
    s += 'y_';
    if (rune.difficulty == 'medium')
      s += '1_';
    else if (rune.difficulty == 'hard')
      s += '2_';
    else if (rune.difficulty == 'marathon')
      s += '3_';
  } else if (rune.type == GLYPH) {
    s += 'b_';
    if (rune.difficulty == 'medium')
      s += '3_';
    else if (rune.difficulty == 'hard')
      s += '1_';
    else if (rune.difficulty == 'marathon')
      s += '2_';
  } else if (rune.type == QUINT) {
    s += 'bl_';
    if (rune.difficulty == 'hard')
      s += '3_';
    else if (rune.difficulty == 'marathon')
      s += '2_';
    else if (rune.difficulty == 'impossible')
      s += '1_';
  }
  s += rune.tier;
  return s;
};
Rune.CreateSet = function (game, type, name, difficulty, applyFunc, tooltipFunc) {
  var set = {};
  for (var i = 1; i <= 3; i++)
    set[i] = new Rune(game, type, name, i, difficulty, applyFunc(i), tooltipFunc(i));
  return set;
};
Rune.Create = function (game) {
  var runes = {};
  // Marks
  var marks = {};
  marks[DAMAGE] = Rune.CreateSet(game, MARK, DAMAGE, 'medium', function (i) {
    return function (obj, num) {
      obj.damage += num * 15 * i;
    };
  }, function (i) {
    return function (game) {
      return this.status == LOCKED ? this.getLockedText() : '+' + 15 * i + ' Damage';
    };
  });
  marks[ATTACKRATE] = Rune.CreateSet(game, MARK, ATTACKRATE, 'medium', function (i) {
    return function (obj, num) {
      obj.attackrate += num * 0.5 * i;
    };
  }, function (i) {
    return function (game) {
      return this.status == LOCKED ? this.getLockedText() : '+' + 0.5 * i + ' Attack Rate';
    };
  });
  marks[MONSTER_CLICKING] = Rune.CreateSet(game, MARK, MONSTER_CLICKING, 'medium', function (i) {
    return function (obj, num) {
      obj.monsterClicking += num * 0.04 * i;
    };
  }, function (i) {
    return function (game) {
      return this.status == LOCKED ? this.getLockedText() : '+' + 4 * i + '% Damage per click';
    };
  });
  marks[SCALING_DAMAGE] = Rune.CreateSet(game, MARK, SCALING_DAMAGE, 'hard', function (i) {
    return function (obj, num) {
      obj.scalingDamage += num * 0.01 * i;
    };
  }, function (i) {
    return function (game) {
      return this.status == LOCKED ? this.getLockedText() : '+' + 1 * i + '% Damage';
    };
  });
  marks[SCALING_ATTACKRATE] = Rune.CreateSet(game, MARK, SCALING_ATTACKRATE, 'hard', function (i) {
    return function (obj, num) {
      obj.scalingAttackrate += num * 0.01 * i;
    };
  }, function (i) {
    return function (game) {
      return this.status == LOCKED ? this.getLockedText() : '+' + 1 * i + '% Attack Rate';
    };
  });
  marks[PENETRATION] = Rune.CreateSet(game, MARK, PENETRATION, 'marathon', function (i) {
    return function (obj, num) {
      obj.penetration += num * 0.02 * i;
    };
  }, function (i) {
    return function (game) {
      return this.status == LOCKED ? this.getLockedText() : '+' + 2 * i + '% Damage to champions';
    };
  });
  runes[MARK] = marks;
  // Seals
  var seals = {};
  seals[MOVESPEED] = Rune.CreateSet(game, SEAL, MOVESPEED, 'medium', function (i) {
    return function (obj, num) {
      obj.movespeed += num * 1 * i;
    };
  }, function (i) {
    return function (game) {
      return this.status == LOCKED ? this.getLockedText() : '+' + 1 * i + ' Move Speed';
    };
  });
  seals[GOLD] = Rune.CreateSet(game, SEAL, GOLD, 'medium', function (i) {
    return function (obj, num) {
      obj.gold += num * 375 * i;
    };
  }, function (i) {
    return function (game) {
      return this.status == LOCKED ? this.getLockedText() : '+' + 375 * i + ' Starting gold';
    };
  });
  seals[CHIME_CLICKING] = Rune.CreateSet(game, SEAL, CHIME_CLICKING, 'medium', function (i) {
    return function (obj, num) {
      obj.chimeClicking += num * 0.06 * i;
    };
  }, function (i) {
    return function (game) {
      return this.status == LOCKED ? this.getLockedText() : '+' + 6 * i + '% Chimes per click';
    };
  });
  seals[SCALING_DEFENSE] = Rune.CreateSet(game, SEAL, SCALING_DEFENSE, 'hard', function (i) {
    return function (obj, num) {
      obj.scalingDefense += num * 0.015 * i;
    };
  }, function (i) {
    return function (game) {
      return this.status == LOCKED ? this.getLockedText() : '+' + 1.5 * i + '% Defense';
    };
  });
  seals[SCALING_MOVESPEED] = Rune.CreateSet(game, SEAL, SCALING_MOVESPEED, 'hard', function (i) {
    return function (obj, num) {
      obj.scalingMoveSpeed += num * 0.015 * i;
    };
  }, function (i) {
    return function (game) {
      return this.status == LOCKED ? this.getLockedText() : '+' + 1.5 * i + '% Move Speed';
    };
  });
  seals[SCALING_GOLD] = Rune.CreateSet(game, SEAL, SCALING_GOLD, 'marathon', function (i) {
    return function (obj, num) {
      obj.scalingGold += num * 0.01 * i;
    };
  }, function (i) {
    return function (game) {
      return this.status == LOCKED ? this.getLockedText() : '+' + 1 * i + '% Gold earned';
    };
  });
  runes[SEAL] = seals;
  // Glyphs;
  var glyphs = {};
  glyphs[SCALING_DAMAGE] = Rune.CreateSet(game, GLYPH, SCALING_DAMAGE, 'medium', function (i) {
    return function (obj, num) {
      obj.scalingDamage += num * 0.01 * i;
    };
  }, function (i) {
    return function (game) {
      return this.status == LOCKED ? this.getLockedText() : '+' + 1 * i + '% Damage';
    };
  });
  glyphs[DEFENSE] = Rune.CreateSet(game, GLYPH, DEFENSE, 'medium', function (i) {
    return function (obj, num) {
      obj.defense += num * 6 * i;
    };
  }, function (i) {
    return function (game) {
      return this.status == LOCKED ? this.getLockedText() : '+' + 6 * i + ' Defense';
    };
  });
  glyphs[COOLDOWN_REDUCTION] = Rune.CreateSet(game, GLYPH, COOLDOWN_REDUCTION, 'medium', function (i) {
    return function (obj, num) {
      obj.cooldownReduction += num * (0.005 + 0.005 * i);
    };
  }, function (i) {
    return function (game) {
      return this.status == LOCKED ? this.getLockedText() : '+' + (0.5 + 0.5 * i) + '% CDR';
    };
  });
  glyphs[SCALING_DEFENSE] = Rune.CreateSet(game, GLYPH, SCALING_DEFENSE, 'hard', function (i) {
    return function (obj, num) {
      obj.scalingDefense += num * 0.01 * i;
    };
  }, function (i) {
    return function (game) {
      return this.status == LOCKED ? this.getLockedText() : '+' + 1 * i + '% Defense';
    };
  });
  glyphs[CLICKING] = Rune.CreateSet(game, GLYPH, CLICKING, 'hard', function (i) {
    return function (obj, num) {
      obj.chimeClicking += num * 0.04 * i;
      obj.monsterClicking += num * 0.04 * i;
    };
  }, function (i) {
    return function (game) {
      return this.status == LOCKED ? this.getLockedText() : '+' + 4 * i + '% Damage/Chimes per click';
    };
  });
  glyphs[SCALING_COOLDOWN_REDUCTION] = Rune.CreateSet(game, GLYPH, SCALING_COOLDOWN_REDUCTION, 'marathon', function (i) {
    return function (obj, num) {
      obj.scalingCooldownReduction += num * (0.01 + 0.005 * i);
    };
  }, function (i) {
    return function (game) {
      return this.status == LOCKED ? this.getLockedText() : '+' + (1 + 0.5 * i) + '% CDR at max level';
    };
  });
  runes[GLYPH] = glyphs;
  // Quints
  var quints = {};
  quints[SCALING_ATTACKRATE] = Rune.CreateSet(game, QUINT, SCALING_ATTACKRATE, 'hard', function (i) {
    return function (obj, num) {
      obj.scalingAttackrate += num * 0.03 * i;
    };
  }, function (i) {
    return function (game) {
      return this.status == LOCKED ? this.getLockedText() : '+' + 3 * i + '% Attack Rate';
    };
  });
  quints[SCALING_MOVESPEED] = Rune.CreateSet(game, QUINT, SCALING_MOVESPEED, 'hard', function (i) {
    return function (obj, num) {
      obj.scalingMovespeed += num * 0.045 * i;
    };
  }, function (i) {
    return function (game) {
      return this.status == LOCKED ? this.getLockedText() : '+' + 4.5 * i + '% Move Speed';
    };
  });
  quints[CLICKING] = Rune.CreateSet(game, QUINT, CLICKING, 'hard', function (i) {
    return function (obj, num) {
      obj.chimeClicking += num * 0.12 * i;
      obj.monsterClicking += num * 0.12 * i;
    };
  }, function (i) {
    return function (game) {
      return this.status == LOCKED ? this.getLockedText() : '+' + 12 * i + '% Damage and Chimes per click';
    };
  });
  quints[PENETRATION] = Rune.CreateSet(game, QUINT, PENETRATION, 'marathon', function (i) {
    return function (obj, num) {
      obj.penetration += num * 0.06 * i;
    };
  }, function (i) {
    return function (game) {
      return this.status == LOCKED ? this.getLockedText() : '+' + 6 * i + '% Damage to champions';
    };
  });
  quints[SCALING_GOLD] = Rune.CreateSet(game, QUINT, SCALING_GOLD, 'marathon', function (i) {
    return function (obj, num) {
      obj.scalingGold += num * 0.03 * i;
    };
  }, function (i) {
    return function (game) {
      return this.status == LOCKED ? this.getLockedText() : '+' + 3 * i + '% Gold earned';
    };
  });
  quints[COOLDOWN_REDUCTION] = Rune.CreateSet(game, QUINT, COOLDOWN_REDUCTION, 'marathon', function (i) {
    return function (obj, num) {
      obj.cooldownReduction += num * (0.015 + 0.015 * i);
    };
  }, function (i) {
    return function (game) {
      return this.status == LOCKED ? this.getLockedText() : '+' + (1.5 + 1.5 * i) + '% CDR';
    };
  });
  quints[TEEMO_SLAYER] = Rune.CreateSet(game, QUINT, TEEMO_SLAYER, 'impossible', function (i) {
    return function (obj, num) {
      obj.teemoSlayer += num * 0.1 * i;
    };
  }, function (i) {
    return function (game) {
      return this.status == LOCKED ? this.getLockedText() : '+' + 10 * i + '% Damage to Teemo';
    };
  });
  runes[QUINT] = quints;
  return runes;
};
Rune.CreateStatsObject = function () {
  obj = {};
  // Rune variables
  obj.defense = 0;
  obj.movespeed = 0;
  obj.damage = 0;
  obj.attackrate = 0;
  obj.scalingDefense = 1;
  obj.scalingMovespeed = 1;
  obj.scalingDamage = 1;
  obj.scalingAttackrate = 1;
  obj.gold = 0;
  obj.scalingGold = 1;
  obj.chimeClicking = 1;
  obj.monsterClicking = 1;
  obj.cooldownReduction = 0;
  obj.scalingCooldownReduction = 0;
  obj.penetration = 1;
  obj.teemoSlayer = 1;
  return obj;
};
var Spell = function (game, duration, cooldown, type, target, start, end, unlock, tooltip) {
  this.Init(game, duration, cooldown, type, target, start, end, unlock, tooltip);
};
Spell.prototype.Init = function (game, duration, cooldown, type, target, start, end, unlock, tooltip) {
  this.game = game;
  this.duration = duration;
  this.durationLeft = 0;
  this.cooldown = cooldown;
  this.cooldownLeft = 0;
  this.type = type;
  this.target = target;
  // callbacks
  this.start = start;
  this.end = end;
  this.unlock = unlock;
  this.tooltip = tooltip;
  this.status = LOCKED;
};
Spell.prototype.getSpellTime = function () {
  var time = 0;
  if (this.status == ACTIVE)
    time = this.durationLeft;
  else if (this.status == COOLDOWN)
    time = this.cooldownLeft;
  return time > 0 ? time.toFixed(0) : '';
};
Spell.Create = function (game) {
  var spells = {};
  // game, duration, cooldown, start, end, unlock, tooltip
  spells[GHOST] = new Spell(game, 10, 90, SPELL_ACTIVE, MONSTER_ALL, function (game) {
    game.ghostBonus = 2;
  }, function (game) {
    game.ghostBonus = 1;
  }, function (game) {
    return game.level >= 4;
  }, function (game) {
    return this.status == LOCKED ? '' : '+100% chime gathering for 10 seconds.  </br></br>' + Math.round(this.cooldown) + ' second cooldown. <b>(Q)</b>';
  });
  spells[FLASH] = new Spell(game, 0, 180, SPELL_ACTIVE, MONSTER_ALL, function (game) {
    game.addMeeps(Math.ceil(game.meepsEarned * game.flashBonus), true);
    showRing(FLASH, RING_DURATION);
  }, function (game) {
  }, function (game) {
    return game.level >= 6;
  }, function (game) {
    return this.status == LOCKED ? '' : '+3% meeps earned from chimes.</br>(<b>' + prettyIntBigCompact(Math.ceil(game.meepsEarned * game.flashBonus)) + '</b>)</br></br>' + Math.round(this.cooldown) + ' second cooldown. <b>(W)</b>';
  });
  spells[SMITE] = new Spell(game, 0, 60, SPELL_ACTIVE, MONSTER_ALL, function (game) {
    if (!game.isMonsterChampion(game.monster)) {
      game.smiteBonus = 0.2;
      game.addDamage(game.getSmiteDamage(), true);
      showRing(SMITE, RING_DURATION);
      game.smiteBonus = 0;
      this.duration = 0;
    } else {
      game.smiteDamageRate = game.getSmiteDamage() / 5;
      showRing(CHALLENGING_SMITE, RING_DURATION);
      this.duration = 5;
    }
  }, function (game) {
    game.smiteDamageRate = 0;
  }, function (game) {
    return game.level >= 2;
  }, function (game) {
    return this.status == LOCKED ? '' : 'Deal <b>' + prettyIntBigCompact(game.getSmiteDamage()) + '</b> damage ' + (!game.isMonsterChampion(game.monster) ? 'instantly' : 'over 5 seconds') + '.  Damage scales with level and experience.</br></br>Non-champion kills with smite grant +20% gold.</br></br>' + Math.round(this.cooldown) + ' second cooldown. <b>(E)</b>';
  });
  spells[EXHAUST] = new Spell(game, 10, 90, SPELL_ACTIVE, MONSTER_CHAMPION, function (game) {
    game.exhaustBonus = 2;
  }, function (game) {
    game.exhaustBonus = 1;
  }, function (game) {
    return game.level >= 16;
  }, function (game) {
    return this.status == LOCKED ? '' : '+100% damage dealt for 10 seconds.  Only works against champions.  </br></br>' + Math.round(this.cooldown) + ' second cooldown. <b>(T)</b>';
  });
  spells[IGNITE] = new Spell(game, 0, 120, SPELL_ACTIVE, MONSTER_ALL, function (game) {
    game.igniteBonus += 0.03;
    game.updateStats();
    showRing(IGNITE + '1', RING_DURATION);
  }, function (game) {
    showRing(IGNITE + '2', RING_DURATION);
  }, function (game) {
    return game.level >= 17;
  }, function (game) {
    return this.status == LOCKED ? '' : '+3% damage from items.</br>(<b>' + prettyIntBigCompact(Math.ceil(game.damageBought * 0.03)) + '</b>)</br></br>' + Math.round(this.cooldown) + ' second cooldown. <b>(R)</b>';
  }  //"Deal <b>" + prettyIntBigCompact(game.igniteDamage) + "</b> damage over 5 seconds.  Damage scales with level.  Only works against champions.  </br></br>120 second cooldown. <b>(R)</b>"}
);
  spells[TELEPORT] = new Spell(game, 0, 300, SPELL_ACTIVE, MONSTER_ALL, function (game) {
  }, function (game) {
    var cooldownSpells = game.getObjectsByStatus(game.spells, COOLDOWN);
    var len = cooldownSpells.length;
    var spell, i;
    for (i = 0; i < len; i++) {
      spell = game.spells[cooldownSpells[i]];
      spell.cooldownLeft = 0;
      spell.status = AVAILABLE;
    }
    var activeSpells = game.getObjectsByStatus(game.spells, ACTIVE);
    len = activeSpells.length;
    for (i = 0; i < len; i++) {
      spell = game.spells[activeSpells[i]];
      spell.durationLeft += spell.duration;
    }
  }, function (game) {
    return game.level >= 13;
  }, function (game) {
    return this.status == LOCKED ? '' : 'Reset cooldowns of all spells.  </br></br>' + Math.round(this.cooldown) + ' second cooldown. <b>(Y)</b>';
  });
  spells[SPOILS_OF_WAR] = new Spell(game, 0, 45, SPELL_PASSIVE, MONSTER_JUNGLE, function (game) {
    game.spoilsOfWarActive = 1;
    game.killMonster();
    game.spoilsOfWarActive = 0;
    showRing(SPOILS_OF_WAR, RING_DURATION);
  }, function (game) {
  }, function (game) {
    return game.upgrades[FACE_OF_THE_MOUNTAIN].status == PURCHASED;
  }, function (game) {
    return this.status == LOCKED ? '' : 'Execute monsters below 25% max health on click, gaining <b>+' + (game.spoilsOfWarBonus * 100).toFixed(1) + '%</b> reward gold.  Gold scales with Relic Shields owned.  Does not work against champions. </br></br>' + Math.round(this.cooldown) + ' second cooldown.';
  });
  spells[FAVOR] = new Spell(game, 0, 0, SPELL_PASSIVE, MONSTER_ALL, function (game) {
  }, function (game) {
  }, function (game) {
    return game.upgrades[TALISMAN_OF_ASCENSION].status == PURCHASED;
  }, function (game) {
    return game.spells[FAVOR].status == LOCKED ? '' : 'Passively gain <b>+' + (game.favorBonus * 100).toFixed(1) + '%</b> gold from monsters killed.  Gold scales with Ancient Coins owned. </br></br>No cooldown.';
  });
  spells[TRIBUTE] = new Spell(game, 0, 30, SPELL_PASSIVE, MONSTER_ALL, function (game) {
    var monster = game.monsters[game.monster];
    var gold = Math.ceil(monster.gold * game.tributeBonus);
    gold /= game.monster == TEEMO ? 15 : 1;
    game.gold += gold;
    game.progress.spells[TRIBUTE].goldGained += gold;
    if (monster.type == MONSTER_CHAMPION) {
      game.addDamage(game.damageStat * game.attackrateStat * game.exhaustBonus * 5);
    }
    showRing(TRIBUTE, RING_DURATION);
  }, function (game) {
  }, function (game) {
    return game.upgrades[FROST_QUEENS_CLAIM].status == PURCHASED;
  }, function (game) {
    if (this.status == LOCKED)
      return '';
    else if (game.monster == TEEMO)
      return 'Gain <b>' + (game.tributeBonus * 100 / 15).toFixed(1) + '%</b> of reward gold on next Teemo click.  Gold scales with Spellthief\'s Edges owned.</br></br>Deals <b>' + prettyIntBigCompact(game.damageStat * game.attackrateStat * game.exhaustBonus * 5, 1) + '</b> bonus damage (scales with DPS).</br></br>' + Math.round(this.cooldown) + ' second cooldown.';
    else
      return 'Gain <b>' + (game.tributeBonus * 100).toFixed(1) + '%</b> of reward gold on next monster click.  Gold scales with Spellthief\'s Edges owned.</br></br>Deals <b>' + prettyIntBigCompact(game.damageStat * game.attackrateStat * game.exhaustBonus * 5, 1) + '</b> bonus damage to champions (scales with DPS).</br></br>' + Math.round(this.cooldown) + ' second cooldown.';
  });
  return spells;
};

var Upgrade = function(game, item, cost, level, defenseStat, movespeedStat, damageStat, attackrateStat, income, requirements) {
  this.Init(game, item, cost, level, defenseStat, movespeedStat, damageStat, attackrateStat, income, requirements);
};

Upgrade.prototype.Init = function(game, item, cost, level, defenseStat, movespeedStat, damageStat, attackrateStat, income, requirements) {
  this.game = game;
  this.item = item;
  this.cost = cost;
  this.level = level;
  this.defenseStat = defenseStat;
  this.movespeedStat = movespeedStat;
  this.damageStat = damageStat;
  this.attackrateStat = attackrateStat;
  this.income = income;

  this.unlock = function(game) {
    if (game.level < this.level)
      return false;
    if (!this.requirements || !this.requirements.length)
      return true;
    for (var i = 0; i < this.requirements.length; i++) {
      if (game.upgrades[this.requirements[i]].status != PURCHASED)
        return false;
    }
    return true;
  };

  this.status = LOCKED;
};

Upgrade.prototype.isZero = function(stat) {
  return this[stat] ? '' : 'upgrade-zero';
};

Upgrade.Create = function(game) {
  var upgrades = {};

  // Boots of Speed
  upgrades[BOOTS_OF_SWIFTNESS] = new Upgrade(game, BOOTS_OF_SPEED,        9000, 4, 0, 2, 0, 0, 0, []);
  upgrades[BOOTS_OF_MOBILITY] = new Upgrade(game, BOOTS_OF_SPEED,         180000, 6, 0, 4, 0, 0, 0, [BOOTS_OF_SWIFTNESS]);
  upgrades[IONIAN_BOOTS_OF_LUCIDITY] = new Upgrade(game, BOOTS_OF_SPEED,  25000000, 9, 0, 8, 0, 5, 0, [BOOTS_OF_MOBILITY]);
  upgrades[MERCURYS_TREADS] = new Upgrade(game, BOOTS_OF_SPEED,           2500000000, 12, 50, 10, 0, 0, 0, [IONIAN_BOOTS_OF_LUCIDITY]);
  upgrades[SORCERERS_SHOES] = new Upgrade(game, BOOTS_OF_SPEED,           400000000000, 15, 0, 25, 100, 0, 0, [MERCURYS_TREADS]);

  // Ancient Coin
  upgrades[NOMADS_MEDALLION] = new Upgrade(game, ANCIENT_COIN,            70000, 5, 0, 2, 0, 0, 25, []);
  upgrades[TALISMAN_OF_ASCENSION] = new Upgrade(game, ANCIENT_COIN,       7000000, 8, 0, 3, 0, 2, 170, [NOMADS_MEDALLION]);

  // Spellthief's Edge
  upgrades[FROSTFANG] = new Upgrade(game, SPELLTHIEFS_EDGE,               50000, 5, 0, 0, 20, 0, 12, []);
  upgrades[FROST_QUEENS_CLAIM] = new Upgrade(game, SPELLTHIEFS_EDGE,      5000000, 8, 0, 0, 70, 2, 85, [FROSTFANG]);

  // Relic Shield
  upgrades[TARGONS_BRACE] = new Upgrade(game, RELIC_SHIELD,               50000, 5, 7, 0, 0, 0, 9, []);
  upgrades[FACE_OF_THE_MOUNTAIN] = new Upgrade(game, RELIC_SHIELD,        5000000, 8, 16, 0, 0, 2, 90, [TARGONS_BRACE]);

  // Ruby Crystal
  upgrades[KINDLEGEM] = new Upgrade(game, RUBY_CRYSTAL,                   90000, 5, 10, 0, 0, 1, 0, []);
  upgrades[CRYSTALLINE_BRACER] = new Upgrade(game, RUBY_CRYSTAL,          1000000, 7, 20, 0, 0, 0, 0, []);
  upgrades[GIANTS_BELT] = new Upgrade(game, RUBY_CRYSTAL,                 35000000, 9, 40, 0, 0, 0, 0, []);
  upgrades[WARMOGS_ARMOR] = new Upgrade(game, RUBY_CRYSTAL,               750000000, 11, 70, 0, 0, 0, 0, [GIANTS_BELT]);
  upgrades[RIGHTEOUS_GLORY] = new Upgrade(game, RUBY_CRYSTAL,             18000000000, 13, 70, 5, 0, 0, 0, [CRYSTALLINE_BRACER]);
  upgrades[LOCKET_OF_THE_IRON_SOLARI] = new Upgrade(game, RUBY_CRYSTAL,   600000000000, 15, 120, 0, 0, 4, 0, [KINDLEGEM]);
  upgrades[FROZEN_MALLET] = new Upgrade(game, RUBY_CRYSTAL,               15000000000000, 17, 160, 0, 100, 0, 0, [GIANTS_BELT]);

  // Amplifying Tome
  upgrades[FIENDISH_CODEX] = new Upgrade(game, AMPLIFYING_TOME,           300000, 6, 0, 0, 50, 1, 0, []);
  upgrades[AETHER_WISP] = new Upgrade(game, AMPLIFYING_TOME,              8000000, 8, 0, 2, 100, 0, 0, []);
  upgrades[NEEDLESSLY_LARGE_ROD] = new Upgrade(game, AMPLIFYING_TOME,     150000000, 10, 0, 0, 200, 0, 0, []);
  upgrades[MORELLONOMICON] = new Upgrade(game, AMPLIFYING_TOME,           4000000000, 12, 0, 0, 200, 4, 0, [FIENDISH_CODEX]);
  upgrades[LUDENS_ECHO] = new Upgrade(game, AMPLIFYING_TOME,              75000000000, 14, 0, 3, 250, 0, 0, [NEEDLESSLY_LARGE_ROD]);
  upgrades[ZHONYAS_HOURGLASS] = new Upgrade(game, AMPLIFYING_TOME,        2000000000000, 16, 50, 0, 350, 0, 0, [NEEDLESSLY_LARGE_ROD]);
  upgrades[RABADONS_DEATHCAP] = new Upgrade(game, AMPLIFYING_TOME,        40000000000000, 18, 0, 0, 800, 0, 0, [NEEDLESSLY_LARGE_ROD]);

  // Dagger
  upgrades[RECURVE_BOW] = new Upgrade(game, DAGGER,                       350000, 6, 0, 0, 0, 2, 0, []);
  upgrades[RUNAANS_HURRICANE] = new Upgrade(game, DAGGER,                 9000000, 8, 0, 0, 20, 3, 0, [RECURVE_BOW]);
  upgrades[ZEAL] = new Upgrade(game, DAGGER,                              450000000, 10, 0, 3, 0, 4, 0, []);
  upgrades[WITS_END] = new Upgrade(game, DAGGER,                          9000000000, 12, 50, 0, 50, 5, 0, [RECURVE_BOW]);
  upgrades[STATIKK_SHIV] = new Upgrade(game, DAGGER,                      150000000000, 14, 0, 3, 80, 5, 0, [ZEAL]);
  upgrades[PHANTOM_DANCER] = new Upgrade(game, DAGGER,                    4500000000000, 16, 0, 4, 0, 10, 0, [ZEAL]);
  upgrades[TRINITY_FORCE] = new Upgrade(game, DAGGER,                     100000000000000, 18, 100, 5, 150, 20, 0, [ZEAL]);

  return upgrades;
};
